// Generated by CoffeeScript 1.3.1
var hashids;

module.exports = hashids = (function() {

  hashids.name = 'hashids';

  function hashids(salt, alphabet, separators) {
    var char, collection, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    this.salt = salt;
    this.alphabet = alphabet != null ? alphabet : "-023456789abdegjklmnopqrtvwxyzABDEGJKLMNOPQRTVWXYZ";
    this.separators = separators != null ? separators : "1fFuUsSiIcChH";
    this.crypto = require('crypto');
    this.alphabetLength = this.alphabet.length;
    if (this.salt.length) {
      this.alphabet = this.shuffle(this.alphabet, this.salt);
    }
    collection = [];
    _ref = this.alphabet;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      char = _ref[_i];
      if (!collection[char]) {
        collection[char] = true;
      } else {
        throw new Error('Warning: Alphabet contains duplicate characters.');
      }
    }
    collection = [];
    _ref1 = this.separators;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      char = _ref1[_j];
      if (!collection[char]) {
        collection[char] = true;
      } else {
        throw new Error('Warning: Separator string contains duplicate characters.');
      }
    }
    _ref2 = this.separators;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      char = _ref2[_k];
      if (this.alphabet.indexOf(char) !== -1) {
        throw new Error('Warning: Separator characters cannot be part of the alphabet.');
      }
    }
  }

  hashids.prototype.encode = function() {
    return this.encodeHash.apply(this, arguments);
  };

  hashids.prototype.decode = function(hash) {
    return this.decodeHash(hash);
  };

  hashids.prototype.encodeHash = function() {
    var alphabet, args, hash, i, number, parameters, subHash, _i, _len;
    hash = '';
    alphabet = this.alphabet;
    args = Array.prototype.slice.call(arguments);
    for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {
      number = arguments[i];
      if (number < 0) {
        hash = '';
        break;
      }
      if (i) {
        parameters = args.slice(0, i);
        hash += this.getSeparator.apply(this, parameters);
      }
      subHash = this.hash(number, alphabet);
      hash += subHash;
      alphabet = this.shuffle(alphabet, this.salt + subHash);
    }
    return hash;
  };

  hashids.prototype.decodeHash = function(hash) {
    var alphabet, c, hashArray, i, number, numbers, subHash, _i, _j, _len, _len1, _ref;
    numbers = [];
    alphabet = this.alphabet;
    hash = hash.trim();
    if (hash) {
      subHash = hash;
      _ref = this.separators;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        subHash = subHash.replace(new RegExp(c, 'g'), ' ');
      }
      hashArray = subHash.split(' ');
      for (i = _j = 0, _len1 = hashArray.length; _j < _len1; i = ++_j) {
        subHash = hashArray[i];
        if (subHash) {
          number = this.unhash(subHash, alphabet);
          numbers.push(number);
          if (i + 1 < hashArray.length) {
            alphabet = this.shuffle(alphabet, this.salt + subHash);
          }
        }
      }
    }
    return numbers;
  };

  hashids.prototype.hash = function(number, alphabet) {
    var alphabetLength, hash;
    hash = '';
    alphabetLength = alphabet.length;
    while (number) {
      hash = alphabet[number % alphabetLength] + hash;
      number = parseInt(number / alphabetLength);
    }
    return hash;
  };

  hashids.prototype.unhash = function(hash, alphabet) {
    var char, i, pos, ret, _i, _len;
    ret = 0;
    for (i = _i = 0, _len = hash.length; _i < _len; i = ++_i) {
      char = hash[i];
      pos = alphabet.indexOf(char);
      ret += pos * Math.pow(alphabet.length, hash.length - i - 1);
    }
    return ret;
  };

  hashids.prototype.shuffle = function(alphabet, salt) {
    var alphabetLength, i, pos, shuffledAlphabet, sorting;
    shuffledAlphabet = '';
    sorting = this.crypto.createHash('md5').update(salt).digest('hex');
    i = 0;
    while (alphabet.length) {
      alphabetLength = alphabet.length;
      pos = parseInt(sorting[i], 16);
      if (pos >= alphabetLength) {
        pos = (alphabetLength - 1) % pos;
      }
      shuffledAlphabet += alphabet[pos];
      alphabet = alphabet.slice(0, pos) + alphabet.slice(pos + 1);
      i++;
      i %= sorting.length;
    }
    return shuffledAlphabet;
  };

  hashids.prototype.getSeparator = function() {
    var argument, i, sum, _i, _len;
    sum = this.alphabetLength;
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      argument = arguments[_i];
      sum += argument;
    }
    i = sum % (this.separators.length - 1);
    return this.separators[i];
  };

  return hashids;

})();
